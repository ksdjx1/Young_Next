function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { Component } from 'react';
import { Icon } from '@iconify/react';
import playCircle from '@iconify/icons-mdi/play-circle';
import pauseCircle from '@iconify/icons-mdi/pause-circle';
import skipPrevious from '@iconify/icons-mdi/skip-previous';
import skipNext from '@iconify/icons-mdi/skip-next';
import fastForward from '@iconify/icons-mdi/fast-forward';
import rewind from '@iconify/icons-mdi/rewind';
import volumeHigh from '@iconify/icons-mdi/volume-high';
import volumeMute from '@iconify/icons-mdi/volume-mute';
import repeat from '@iconify/icons-mdi/repeat';
import repeatOff from '@iconify/icons-mdi/repeat-off';

class H5AudioPlayer extends Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "state", void 0);

    _defineProperty(this, "audio", void 0);

    _defineProperty(this, "volumeControl", void 0);

    _defineProperty(this, "progressBar", void 0);

    _defineProperty(this, "container", void 0);

    _defineProperty(this, "lastVolume", void 0);

    _defineProperty(this, "timeOnMouseMove", void 0);

    _defineProperty(this, "listenTracker", void 0);

    _defineProperty(this, "intervalId", void 0);

    _defineProperty(this, "updateDisplayTime", currentTime => {
      var duration = this.audio.duration;
      this.setState({
        currentTime,
        duration: this.audio.duration,
        currentTimePos: "".concat((currentTime / duration * 100 || 0).toFixed(2), "%")
      });
    });

    _defineProperty(this, "updateDisplayVolume", volume => {
      this.setState({
        currentVolume: volume,
        currentVolumePos: "".concat((volume * 100).toFixed(0), "%")
      });
    });

    _defineProperty(this, "togglePlay", e => {
      e.stopPropagation();

      if (this.audio.paused && this.audio.src) {
        var audioPromise = this.audio.play();
        audioPromise.then(null).catch(err => {
          var {
            onPlayError
          } = this.props;
          onPlayError && onPlayError(new Error(err));
        });
      } else if (!this.audio.paused) {
        this.audio.pause();
      }
    });

    _defineProperty(this, "handleClickVolumeButton", () => {
      var {
        currentVolume
      } = this.state;

      if (currentVolume > 0) {
        this.lastVolume = this.audio.volume;
        this.audio.volume = 0;
        this.updateDisplayVolume(0);
      } else {
        this.audio.volume = this.lastVolume;
        this.updateDisplayVolume(this.lastVolume);
      }
    });

    _defineProperty(this, "handleVolumnControlMouseDown", event => {
      event.stopPropagation();
      var {
        currentVolume,
        currentVolumePos
      } = this.getCurrentVolume(event.nativeEvent);
      this.audio.volume = currentVolume;
      this.setState({
        isDraggingVolume: true,
        currentVolume,
        currentVolumePos
      });

      if (event.nativeEvent instanceof TouchEvent) {
        window.addEventListener('touchmove', this.handleWindowMouseOrTouchMove);
        window.addEventListener('touchend', this.handleWindowMouseOrTouchUp);
      } else if (event.nativeEvent instanceof MouseEvent) {
        window.addEventListener('mousemove', this.handleWindowMouseOrTouchMove);
        window.addEventListener('mouseup', this.handleWindowMouseOrTouchUp);
      }
    });

    _defineProperty(this, "handleWindowMouseOrTouchMove", event => {
      event.stopPropagation();
      var windowSelection = window.getSelection();

      if (windowSelection && windowSelection.type === 'Range') {
        windowSelection.empty();
      }

      var {
        isDraggingVolume,
        isDraggingProgress
      } = this.state;

      if (isDraggingVolume) {
        var {
          currentVolume,
          currentVolumePos
        } = this.getCurrentVolume(event);
        this.audio.volume = currentVolume;
        this.setState({
          currentVolume,
          currentVolumePos
        });
      } else if (isDraggingProgress) {
        var {
          currentTime: _currentTime,
          currentTimePos
        } = this.getCurrentProgress(event);
        this.timeOnMouseMove = _currentTime;
        this.setState({
          currentTime: _currentTime,
          currentTimePos
        });
      }
    });

    _defineProperty(this, "handleWindowMouseOrTouchUp", event => {
      event.stopPropagation();
      this.setState(prevState => {
        if (prevState.isDraggingProgress && isFinite(this.timeOnMouseMove)) {
          this.audio.currentTime = this.timeOnMouseMove;
        }

        return {
          isDraggingVolume: false,
          isDraggingProgress: false
        };
      });

      if (event instanceof TouchEvent) {
        window.removeEventListener('touchmove', this.handleWindowMouseOrTouchMove);
        window.removeEventListener('touchend', this.handleWindowMouseOrTouchUp);
      } else {
        window.removeEventListener('mousemove', this.handleWindowMouseOrTouchMove);
        window.removeEventListener('mouseup', this.handleWindowMouseOrTouchUp);
      }
    });

    _defineProperty(this, "getCurrentVolume", event => {
      if (!this.volumeControl) {
        return {
          currentVolume: this.state.currentVolume,
          currentVolumePos: this.state.currentVolumePos
        };
      }

      var volumeBarRect = this.volumeControl.getBoundingClientRect();
      var relativePos = H5AudioPlayer.getPosX(event) - volumeBarRect.left;
      var currentVolume;
      var currentVolumePos;

      if (relativePos < 0) {
        currentVolume = 0;
        currentVolumePos = '0%';
      } else if (relativePos > volumeBarRect.width) {
        currentVolume = 1;
        currentVolumePos = "".concat(volumeBarRect.width / volumeBarRect.width * 100, "%");
      } else {
        currentVolume = relativePos / volumeBarRect.width;
        currentVolumePos = "".concat(relativePos / volumeBarRect.width * 100, "%");
      }

      return {
        currentVolume,
        currentVolumePos
      };
    });

    _defineProperty(this, "handleMouseDownProgressBar", event => {
      event.stopPropagation();
      var isTouch = event.type.startsWith('touch');
      var {
        currentTime,
        currentTimePos
      } = this.getCurrentProgress(event.nativeEvent);

      if (isFinite(currentTime)) {
        this.timeOnMouseMove = currentTime;
        this.setState({
          isDraggingProgress: true,
          currentTime,
          currentTimePos
        });

        if (isTouch) {
          window.addEventListener('touchmove', this.handleWindowMouseOrTouchMove);
          window.addEventListener('touchend', this.handleWindowMouseOrTouchUp);
        } else {
          window.addEventListener('mousemove', this.handleWindowMouseOrTouchMove);
          window.addEventListener('mouseup', this.handleWindowMouseOrTouchUp);
        }
      }
    });

    _defineProperty(this, "handleClickLoopButton", () => {
      this.setState(prevState => ({
        isLoopEnabled: !prevState.isLoopEnabled
      }));
    });

    _defineProperty(this, "handleClickRewind", () => {
      this.setJumpTime(-this.props.progressJumpStep);
    });

    _defineProperty(this, "handleClickForward", () => {
      this.setJumpTime(this.props.progressJumpStep);
    });

    _defineProperty(this, "setJumpTime", time => {
      var {
        duration,
        currentTime
      } = this.audio;
      if (!isFinite(duration) || !isFinite(currentTime)) return;
      this.setState(prevState => {
        var currentTime = prevState.currentTime + time / 1000;

        if (currentTime < 0) {
          this.audio.currentTime = 0;
          currentTime = 0;
        } else if (currentTime > duration) {
          this.audio.currentTime = duration;
          currentTime = duration;
        } else {
          this.audio.currentTime = currentTime;
        }

        return {
          currentTime,
          currentTimePos: "".concat(currentTime / duration * 100, "%")
        };
      });
    });

    _defineProperty(this, "setJumpVolume", volume => {
      var newVolume = this.audio.volume + volume;
      if (newVolume < 0) newVolume = 0;else if (newVolume > 1) newVolume = 1;
      this.audio.volume = newVolume;
      this.updateDisplayVolume(newVolume);
    });

    _defineProperty(this, "getCurrentProgress", event => {
      if (!this.audio.src || !isFinite(this.audio.currentTime) || !this.progressBar) {
        return {
          currentTime: 0,
          currentTimePos: '0%'
        };
      }

      var progressBarRect = this.progressBar.getBoundingClientRect();
      var maxRelativePos = progressBarRect.width;
      var relativePos = H5AudioPlayer.getPosX(event) - progressBarRect.left;

      if (relativePos < 0) {
        relativePos = 0;
      } else if (relativePos > maxRelativePos) {
        relativePos = maxRelativePos;
      }

      var currentTime = this.audio.duration * relativePos / maxRelativePos;
      return {
        currentTime,
        currentTimePos: "".concat((relativePos / maxRelativePos * 100).toFixed(2), "%")
      };
    });

    _defineProperty(this, "getDisplayTimeBySeconds", seconds => {
      if (!isFinite(seconds)) {
        return '00:00';
      }

      var addHeadingZero = H5AudioPlayer.addHeadingZero;
      var min = addHeadingZero(Math.floor(seconds / 60));
      var sec = addHeadingZero(Math.floor(seconds % 60));
      return "".concat(min, ":").concat(sec);
    });

    _defineProperty(this, "setListenTrack", () => {
      if (!this.listenTracker) {
        var listenInterval = this.props.listenInterval;
        this.listenTracker = setInterval(() => {
          this.props.onListen && this.props.onListen(this.audio.currentTime);
        }, listenInterval);
      }
    });

    _defineProperty(this, "clearListenTrack", () => {
      if (this.listenTracker) {
        clearInterval(this.listenTracker);
        delete this.listenTracker;
      }
    });

    _defineProperty(this, "handleKeyDown", e => {
      switch (e.keyCode) {
        case 32:
          if (e.target === this.container || e.target === this.progressBar) {
            this.togglePlay(e);
          }

          break;

        case 37:
          this.handleClickRewind();
          break;

        case 39:
          this.handleClickForward();
          break;

        case 38:
          this.setJumpVolume(this.props.volumeJumpStep);
          break;

        case 40:
          this.setJumpVolume(-this.props.volumeJumpStep);
          break;

        case 76:
          this.handleClickLoopButton();
          break;

        case 77:
          this.handleClickVolumeButton();
          break;
      }
    });

    var {
      volume: _volume,
      muted
    } = props;
    this.state = {
      duration: NaN,
      currentTime: 0,
      currentTimePos: '0%',
      currentVolume: muted ? 0 : _volume,
      currentVolumePos: muted ? '0%' : "".concat(_volume * 100, "%"),
      isDraggingProgress: false,
      isDraggingVolume: false,
      isPlaying: false,
      isLoopEnabled: this.props.loop,
      downloadProgressArr: []
    };
    this.lastVolume = _volume;
    this.timeOnMouseMove = 0;
  }

  componentDidMount() {
    this.audio = this.audio || document.createElement('audio');
    var audio = this.audio;
    audio.volume = this.lastVolume;
    this.intervalId = setInterval(() => {
      if (!this.audio.paused && !this.state.isDraggingProgress && !!this.audio.duration) {
        this.updateDisplayTime(this.audio.currentTime);
      }
    }, this.props.progressUpdateInterval);
    audio.addEventListener('error', e => {
      this.props.onError && this.props.onError(e);
    });
    audio.addEventListener('canplay', e => {
      if (isFinite(this.audio.duration)) {
        this.setState({
          duration: this.audio.duration
        });
      }

      this.props.onCanPlay && this.props.onCanPlay(e);
    });
    audio.addEventListener('canplaythrough', e => {
      this.props.onCanPlayThrough && this.props.onCanPlayThrough(e);
    });
    audio.addEventListener('play', e => {
      this.setState({
        isPlaying: true
      });
      this.setListenTrack();
      this.props.onPlay && this.props.onPlay(e);
    });
    audio.addEventListener('abort', e => {
      this.clearListenTrack();
      var {
        autoPlayAfterSrcChange
      } = this.props;

      if (autoPlayAfterSrcChange) {
        this.audio.play();
      } else {
        this.setState({
          isPlaying: false,
          currentTime: 0,
          currentTimePos: '0%'
        });
      }

      this.props.onAbort && this.props.onAbort(e);
    });
    audio.addEventListener('ended', e => {
      this.clearListenTrack();
      this.props.onEnded && this.props.onEnded(e);
    });
    audio.addEventListener('pause', e => {
      this.clearListenTrack();
      if (!this.audio) return;
      this.setState({
        isPlaying: false
      });
      this.props.onPause && this.props.onPause(e);
    });
    audio.addEventListener('progress', () => {
      var audio = this.audio;
      var downloadProgressArr = [];

      for (var i = 0; i < audio.buffered.length; i++) {
        var bufferedStart = audio.buffered.start(i);
        var bufferedEnd = audio.buffered.end(i);
        downloadProgressArr.push({
          left: "".concat(Math.round(100 / audio.duration * bufferedStart) || 0, "%"),
          width: "".concat(Math.round(100 / audio.duration * (bufferedEnd - bufferedStart)) || 0, "%")
        });
      }

      this.setState({
        downloadProgressArr
      });
    });
  }

  componentWillUnmount() {
    clearInterval(this.intervalId);
  }

  render() {
    var {
      className,
      src,
      preload,
      autoPlay,
      muted,
      crossOrigin,
      mediaGroup,
      showLoopControl,
      showVolumeControl,
      showSkipControls,
      showJumpControls,
      onClickPrevious,
      onClickNext,
      showDownloadProgress,
      children,
      style
    } = this.props;
    var {
      currentTime,
      currentTimePos,
      currentVolume,
      currentVolumePos,
      duration,
      isPlaying,
      isLoopEnabled,
      downloadProgressArr
    } = this.state;
    return React.createElement("div", {
      role: "group",
      tabIndex: 0,
      "aria-label": "Audio Player",
      className: "rhap_container ".concat(className),
      onKeyDown: this.handleKeyDown,
      ref: _ref5 => {
        this.container = _ref5;
      },
      style: style
    }, React.createElement("audio", {
      src: src,
      controls: false,
      muted: muted,
      loop: isLoopEnabled,
      autoPlay: autoPlay,
      preload: preload,
      crossOrigin: crossOrigin,
      mediaGroup: mediaGroup,
      ref: _ref => {
        this.audio = _ref;
      }
    }, children), React.createElement("div", {
      className: "rhap_progress-section"
    }, React.createElement("div", {
      id: "rhap_current-time",
      className: "rhap_time rhap_current-time"
    }, this.getDisplayTimeBySeconds(currentTime)), React.createElement("div", {
      className: "rhap_progress-container",
      ref: _ref3 => {
        this.progressBar = _ref3;
      },
      "aria-label": "Audio Progress Control",
      "aria-describedby": "rhap_current-time",
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": Number(currentTimePos.split('%')[0]),
      tabIndex: 0,
      onMouseDown: this.handleMouseDownProgressBar,
      onTouchStart: this.handleMouseDownProgressBar
    }, React.createElement("div", {
      className: "rhap_progress-bar ".concat(showDownloadProgress ? 'rhap_progress-bar-show-download' : '')
    }, React.createElement("div", {
      className: "rhap_progress-indicator",
      style: {
        left: currentTimePos
      }
    }), showDownloadProgress && downloadProgressArr.map((_ref2, i) => {
      var {
        left,
        width
      } = _ref2;
      return React.createElement("div", {
        key: i,
        className: "rhap_download-progress",
        style: {
          left,
          width
        }
      });
    }))), React.createElement("div", {
      className: "rhap_time rhap_total-time"
    }, this.getDisplayTimeBySeconds(duration))), React.createElement("div", {
      className: "rhap_controls-section"
    }, React.createElement("div", {
      className: "rhap_additional-controls"
    }, showLoopControl && React.createElement("button", {
      "aria-label": isLoopEnabled ? 'Enable Loop' : 'Disable Loop',
      className: "rhap_button-clear rhap_repeat-button",
      onClick: this.handleClickLoopButton
    }, React.createElement(Icon, {
      icon: isLoopEnabled ? repeat : repeatOff
    }))), React.createElement("div", {
      className: "rhap_main-controls"
    }, showSkipControls && React.createElement("button", {
      "aria-label": "Previous",
      className: "rhap_button-clear rhap_main-controls-button rhap_skip-button",
      onClick: onClickPrevious
    }, React.createElement(Icon, {
      icon: skipPrevious
    })), showJumpControls && React.createElement("button", {
      "aria-label": "Rewind",
      className: "rhap_button-clear rhap_main-controls-button rhap_rewind-button",
      onClick: this.handleClickRewind
    }, React.createElement(Icon, {
      icon: rewind
    })), React.createElement("button", {
      "aria-label": isPlaying ? 'Pause' : 'Play',
      className: "rhap_button-clear rhap_main-controls-button rhap_play-pause-button",
      onClick: this.togglePlay
    }, isPlaying ? React.createElement(Icon, {
      icon: pauseCircle
    }) : React.createElement(Icon, {
      icon: playCircle
    })), showJumpControls && React.createElement("button", {
      "aria-label": "Forward",
      className: "rhap_button-clear rhap_main-controls-button rhap_forward-button",
      onClick: this.handleClickForward
    }, React.createElement(Icon, {
      icon: fastForward
    })), showSkipControls && React.createElement("button", {
      "aria-label": "Skip",
      className: "rhap_button-clear rhap_main-controls-button rhap_skip-button",
      onClick: onClickNext
    }, React.createElement(Icon, {
      icon: skipNext
    }))), React.createElement("div", {
      className: "rhap_volume-controls"
    }, showVolumeControl && React.createElement("div", {
      className: "rhap_volume-container"
    }, React.createElement("button", {
      "aria-label": currentVolume ? 'Mute' : 'Unmute',
      onClick: this.handleClickVolumeButton,
      className: "rhap_button-clear rhap_volume-button"
    }, React.createElement(Icon, {
      icon: currentVolume ? volumeHigh : volumeMute
    })), React.createElement("div", {
      ref: _ref4 => {
        this.volumeControl = _ref4;
      },
      onMouseDown: this.handleVolumnControlMouseDown,
      onTouchStart: this.handleVolumnControlMouseDown,
      role: "progressbar",
      "aria-label": "volume Control",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": Number((currentVolume * 100).toFixed(0)),
      tabIndex: 0,
      className: "rhap_volume-bar-area"
    }, React.createElement("div", {
      className: "rhap_volume-bar"
    }, React.createElement("div", {
      className: "rhap_volume-indicator",
      style: {
        left: currentVolumePos
      }
    })))))));
  }

}

_defineProperty(H5AudioPlayer, "defaultProps", {
  autoPlay: false,
  autoPlayAfterSrcChange: true,
  listenInterval: 1000,
  progressJumpStep: 5000,
  volumeJumpStep: 0.1,
  loop: false,
  muted: false,
  preload: 'auto',
  progressUpdateInterval: 20,
  volume: 1.0,
  className: '',
  showLoopControl: true,
  showVolumeControl: true,
  showJumpControls: true,
  showSkipControls: false,
  showDownloadProgress: true
});

_defineProperty(H5AudioPlayer, "addHeadingZero", num => num > 9 ? num.toString() : "0".concat(num));

_defineProperty(H5AudioPlayer, "getPosX", event => {
  var posX = 0;

  if (event instanceof TouchEvent) {
    posX = event.touches[0].pageX;
  } else if (event instanceof MouseEvent) {
    posX = event.pageX || event.clientX;
  }

  return posX;
});

export default H5AudioPlayer;